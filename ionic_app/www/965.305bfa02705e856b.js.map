{"version":3,"file":"965.305bfa02705e856b.js","mappings":"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","names":["animationPrefix","convertCamelCaseToHypen","str","replace","toLowerCase","getAnimationPrefix","el","undefined","style","animationName","webkitAnimationName","setStyleProperty","element","propertyName","value","prefix","startsWith","setProperty","removeStyleProperty","removeProperty","keyframeIds","addClassToArray","classes","className","classNameToAppend","Array","isArray","createAnimation","animationId","_delay","_duration","_easing","_iterations","_fill","_direction","parentAnimation","cssAnimationsTimerFallback","forceDirectionValue","forceDurationValue","forceDelayValue","keyframeName","ani","_keyframes","beforeAddClasses","beforeRemoveClasses","initialized","beforeStylesValue","afterAddClasses","afterRemoveClasses","afterStylesValue","numAnimationsRunning","shouldForceLinearEasing","shouldForceSyncPlayback","willComplete","finished","shouldCalculateNumAnimations","paused","id","onFinishCallbacks","onFinishOneTimeCallbacks","onStopOneTimeCallbacks","elements","childAnimations","stylesheets","_beforeAddReadFunctions","_beforeAddWriteFunctions","_afterAddReadFunctions","_afterAddWriteFunctions","webAnimations","supportsAnimationEffect","AnimationEffect","win","supportsWebAnimations","Element","prototype","animate","getWebAnimations","clearCallback","callbackToRemove","callbackObjects","index","findIndex","callbackObject","c","splice","onFinish","callback","opts","oneTimeCallback","push","o","cleanUpElements","forEach","animation","cancel","length","elementsArray","slice","raf","cleanUpStyleSheets","stylesheet","parentNode","removeChild","getFill","getDirection","getEasing","getDuration","getIterations","getDelay","animationFinish","afterAnimation","clearCSSAnimationsTimeout","currentStep","addClasses","removeClasses","styles","elementClassList","classList","add","remove","property","hasOwnProperty","onFinishCallback","initializeCSSAnimation","toggleAnimationName","processedKeyframes","keyframes","keyframe","key","newKey","processKeyframes","keyframeRules","generateKeyframeRules","map","offset","frameString","join","indexOf","generateKeyframeName","createKeyframeStylesheet","_a","styleContainer","rootNode","getRootNode","head","getStyleContainer","keyframePrefix","existingStylesheet","querySelector","ownerDocument","document","createElement","textContent","appendChild","iterationsCount","Infinity","toString","initializeAnimation","beforeAnimation","delay","duration","easing","iterations","fill","direction","pause","onfinish","setAnimationStep","step","Math","min","max","currentTime","effect","getComputedTiming","animationDuration","updateWebAnimation","updateTiming","updateCSSAnimation","update","deep","pauseAnimation","onAnimationEndFallback","clearTimeout","play","Promise","resolve","sync","onStopCallback","onStop","playCSSAnimations","animationDelay","animationIterations","isFinite","setTimeout","animationEnd","unRegTrans","passive","onTransitionEnd","ev","target","addEventListener","removeEventListener","unregister","from","firstFrame","n","to","lastFrame","fromTo","fromValue","toValue","parent","stop","destroy","clearStyleSheets","childAnimation","cleanUp","keyframeValues","different","keyframeEffect","setKeyframes","newEffect","KeyframeEffect","getTiming","updateKeyframes","addAnimation","animationToAdd","addElement","nodeType","i","console","error","animationFill","animationDirection","animationEasing","getKeyframes","afterAddRead","readFn","afterAddWrite","writeFn","afterClearStyles","propertyNames","afterStyles","afterRemoveClass","afterAddClass","beforeAddRead","beforeAddWrite","beforeClearStyles","beforeStyles","beforeRemoveClass","beforeAddClass","isRunning","progressStart","forceLinearEasing","progressStep","progressEnd","playTo","dur"],"sourceRoot":"webpack:///","sources":["./node_modules/@ionic/core/components/animation.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index5.js';\nimport { r as raf } from './helpers.js';\n\nlet animationPrefix;\n/**\n * Web Animations requires hyphenated CSS properties\n * to be written in camelCase when animating\n */\nconst processKeyframes = (keyframes) => {\n  keyframes.forEach((keyframe) => {\n    for (const key in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(key)) {\n        const value = keyframe[key];\n        if (key === 'easing') {\n          const newKey = 'animation-timing-function';\n          keyframe[newKey] = value;\n          delete keyframe[key];\n        }\n        else {\n          const newKey = convertCamelCaseToHypen(key);\n          if (newKey !== key) {\n            keyframe[newKey] = value;\n            delete keyframe[key];\n          }\n        }\n      }\n    }\n  });\n  return keyframes;\n};\nconst convertCamelCaseToHypen = (str) => {\n  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n};\nconst getAnimationPrefix = (el) => {\n  if (animationPrefix === undefined) {\n    const supportsUnprefixed = el.style.animationName !== undefined;\n    const supportsWebkitPrefix = el.style.webkitAnimationName !== undefined;\n    animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? '-webkit-' : '';\n  }\n  return animationPrefix;\n};\nconst setStyleProperty = (element, propertyName, value) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.setProperty(prefix + propertyName, value);\n};\nconst removeStyleProperty = (element, propertyName) => {\n  const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';\n  element.style.removeProperty(prefix + propertyName);\n};\nconst animationEnd = (el, callback) => {\n  let unRegTrans;\n  const opts = { passive: true };\n  const unregister = () => {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  };\n  const onTransitionEnd = (ev) => {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  };\n  if (el) {\n    el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n    el.addEventListener('animationend', onTransitionEnd, opts);\n    unRegTrans = () => {\n      el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);\n      el.removeEventListener('animationend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n};\n// TODO(FW-2832): type\nconst generateKeyframeRules = (keyframes = []) => {\n  return keyframes\n    .map((keyframe) => {\n    const offset = keyframe.offset;\n    const frameString = [];\n    for (const property in keyframe) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (keyframe.hasOwnProperty(property) && property !== 'offset') {\n        frameString.push(`${property}: ${keyframe[property]};`);\n      }\n    }\n    return `${offset * 100}% { ${frameString.join(' ')} }`;\n  })\n    .join(' ');\n};\nconst keyframeIds = [];\nconst generateKeyframeName = (keyframeRules) => {\n  let index = keyframeIds.indexOf(keyframeRules);\n  if (index < 0) {\n    index = keyframeIds.push(keyframeRules) - 1;\n  }\n  return `ion-animation-${index}`;\n};\nconst getStyleContainer = (element) => {\n  // getRootNode is not always available in SSR environments.\n  // TODO(FW-2832): types\n  const rootNode = element.getRootNode !== undefined ? element.getRootNode() : element;\n  return rootNode.head || rootNode;\n};\nconst createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {\n  var _a;\n  const styleContainer = getStyleContainer(element);\n  const keyframePrefix = getAnimationPrefix(element);\n  const existingStylesheet = styleContainer.querySelector('#' + keyframeName);\n  if (existingStylesheet) {\n    return existingStylesheet;\n  }\n  const stylesheet = ((_a = element.ownerDocument) !== null && _a !== void 0 ? _a : document).createElement('style');\n  stylesheet.id = keyframeName;\n  stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;\n  styleContainer.appendChild(stylesheet);\n  return stylesheet;\n};\nconst addClassToArray = (classes = [], className) => {\n  if (className !== undefined) {\n    const classNameToAppend = Array.isArray(className) ? className : [className];\n    return [...classes, ...classNameToAppend];\n  }\n  return classes;\n};\n\nconst createAnimation = (animationId) => {\n  let _delay;\n  let _duration;\n  let _easing;\n  let _iterations;\n  let _fill;\n  let _direction;\n  let _keyframes = [];\n  let beforeAddClasses = [];\n  let beforeRemoveClasses = [];\n  let initialized = false;\n  let parentAnimation;\n  let beforeStylesValue = {};\n  let afterAddClasses = [];\n  let afterRemoveClasses = [];\n  let afterStylesValue = {};\n  let numAnimationsRunning = 0;\n  let shouldForceLinearEasing = false;\n  let shouldForceSyncPlayback = false;\n  let cssAnimationsTimerFallback;\n  let forceDirectionValue;\n  let forceDurationValue;\n  let forceDelayValue;\n  let willComplete = true;\n  let finished = false;\n  let shouldCalculateNumAnimations = true;\n  let keyframeName;\n  let ani;\n  let paused = false;\n  const id = animationId;\n  const onFinishCallbacks = [];\n  const onFinishOneTimeCallbacks = [];\n  const onStopOneTimeCallbacks = [];\n  const elements = [];\n  const childAnimations = [];\n  const stylesheets = [];\n  const _beforeAddReadFunctions = [];\n  const _beforeAddWriteFunctions = [];\n  const _afterAddReadFunctions = [];\n  const _afterAddWriteFunctions = [];\n  const webAnimations = [];\n  const supportsAnimationEffect = typeof AnimationEffect === 'function' ||\n    (win !== undefined && typeof win.AnimationEffect === 'function');\n  const supportsWebAnimations = typeof Element === 'function' &&\n    typeof Element.prototype.animate === 'function' &&\n    supportsAnimationEffect;\n  const ANIMATION_END_FALLBACK_PADDING_MS = 100;\n  const getWebAnimations = () => {\n    return webAnimations;\n  };\n  const destroy = (clearStyleSheets) => {\n    childAnimations.forEach((childAnimation) => {\n      childAnimation.destroy(clearStyleSheets);\n    });\n    cleanUp(clearStyleSheets);\n    elements.length = 0;\n    childAnimations.length = 0;\n    _keyframes.length = 0;\n    clearOnFinish();\n    initialized = false;\n    shouldCalculateNumAnimations = true;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations, removes\n   * any animation properties from the\n   * animation's elements, and removes the\n   * animation's stylesheets from the DOM.\n   */\n  const cleanUp = (clearStyleSheets) => {\n    cleanUpElements();\n    if (clearStyleSheets) {\n      cleanUpStyleSheets();\n    }\n  };\n  const resetFlags = () => {\n    shouldForceLinearEasing = false;\n    shouldForceSyncPlayback = false;\n    shouldCalculateNumAnimations = true;\n    forceDirectionValue = undefined;\n    forceDurationValue = undefined;\n    forceDelayValue = undefined;\n    numAnimationsRunning = 0;\n    finished = false;\n    willComplete = true;\n    paused = false;\n  };\n  const isRunning = () => {\n    return numAnimationsRunning !== 0 && !paused;\n  };\n  /**\n   * @internal\n   * Remove a callback from a chosen callback array\n   * @param callbackToRemove: A reference to the callback that should be removed\n   * @param callbackObjects: An array of callbacks that callbackToRemove should be removed from.\n   */\n  const clearCallback = (callbackToRemove, callbackObjects) => {\n    const index = callbackObjects.findIndex((callbackObject) => callbackObject.c === callbackToRemove);\n    if (index > -1) {\n      callbackObjects.splice(index, 1);\n    }\n  };\n  /**\n   * @internal\n   * Add a callback to be fired when an animation is stopped/cancelled.\n   * @param callback: A reference to the callback that should be fired\n   * @param opts: Any options associated with this particular callback\n   */\n  const onStop = (callback, opts) => {\n    onStopOneTimeCallbacks.push({ c: callback, o: opts });\n    return ani;\n  };\n  const onFinish = (callback, opts) => {\n    const callbacks = (opts === null || opts === void 0 ? void 0 : opts.oneTimeCallback) ? onFinishOneTimeCallbacks : onFinishCallbacks;\n    callbacks.push({ c: callback, o: opts });\n    return ani;\n  };\n  const clearOnFinish = () => {\n    onFinishCallbacks.length = 0;\n    onFinishOneTimeCallbacks.length = 0;\n    return ani;\n  };\n  /**\n   * Cancels any Web Animations and removes\n   * any animation properties from the\n   * the animation's elements.\n   */\n  const cleanUpElements = () => {\n    if (supportsWebAnimations) {\n      webAnimations.forEach((animation) => {\n        animation.cancel();\n      });\n      webAnimations.length = 0;\n    }\n    else {\n      const elementsArray = elements.slice();\n      raf(() => {\n        elementsArray.forEach((element) => {\n          removeStyleProperty(element, 'animation-name');\n          removeStyleProperty(element, 'animation-duration');\n          removeStyleProperty(element, 'animation-timing-function');\n          removeStyleProperty(element, 'animation-iteration-count');\n          removeStyleProperty(element, 'animation-delay');\n          removeStyleProperty(element, 'animation-play-state');\n          removeStyleProperty(element, 'animation-fill-mode');\n          removeStyleProperty(element, 'animation-direction');\n        });\n      });\n    }\n  };\n  /**\n   * Removes the animation's stylesheets\n   * from the DOM.\n   */\n  const cleanUpStyleSheets = () => {\n    stylesheets.forEach((stylesheet) => {\n      /**\n       * When sharing stylesheets, it's possible\n       * for another animation to have already\n       * cleaned up a particular stylesheet\n       */\n      if (stylesheet === null || stylesheet === void 0 ? void 0 : stylesheet.parentNode) {\n        stylesheet.parentNode.removeChild(stylesheet);\n      }\n    });\n    stylesheets.length = 0;\n  };\n  const beforeAddRead = (readFn) => {\n    _beforeAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const beforeAddWrite = (writeFn) => {\n    _beforeAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const afterAddRead = (readFn) => {\n    _afterAddReadFunctions.push(readFn);\n    return ani;\n  };\n  const afterAddWrite = (writeFn) => {\n    _afterAddWriteFunctions.push(writeFn);\n    return ani;\n  };\n  const beforeAddClass = (className) => {\n    beforeAddClasses = addClassToArray(beforeAddClasses, className);\n    return ani;\n  };\n  const beforeRemoveClass = (className) => {\n    beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);\n    return ani;\n  };\n  /**\n   * Set CSS inline styles to the animation's\n   * elements before the animation begins.\n   */\n  const beforeStyles = (styles = {}) => {\n    beforeStylesValue = styles;\n    return ani;\n  };\n  /**\n   * Clear CSS inline styles from the animation's\n   * elements before the animation begins.\n   */\n  const beforeClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      beforeStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const afterAddClass = (className) => {\n    afterAddClasses = addClassToArray(afterAddClasses, className);\n    return ani;\n  };\n  const afterRemoveClass = (className) => {\n    afterRemoveClasses = addClassToArray(afterRemoveClasses, className);\n    return ani;\n  };\n  const afterStyles = (styles = {}) => {\n    afterStylesValue = styles;\n    return ani;\n  };\n  const afterClearStyles = (propertyNames = []) => {\n    for (const property of propertyNames) {\n      afterStylesValue[property] = '';\n    }\n    return ani;\n  };\n  const getFill = () => {\n    if (_fill !== undefined) {\n      return _fill;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getFill();\n    }\n    return 'both';\n  };\n  const getDirection = () => {\n    if (forceDirectionValue !== undefined) {\n      return forceDirectionValue;\n    }\n    if (_direction !== undefined) {\n      return _direction;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDirection();\n    }\n    return 'normal';\n  };\n  const getEasing = () => {\n    if (shouldForceLinearEasing) {\n      return 'linear';\n    }\n    if (_easing !== undefined) {\n      return _easing;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getEasing();\n    }\n    return 'linear';\n  };\n  const getDuration = () => {\n    if (shouldForceSyncPlayback) {\n      return 0;\n    }\n    if (forceDurationValue !== undefined) {\n      return forceDurationValue;\n    }\n    if (_duration !== undefined) {\n      return _duration;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDuration();\n    }\n    return 0;\n  };\n  const getIterations = () => {\n    if (_iterations !== undefined) {\n      return _iterations;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getIterations();\n    }\n    return 1;\n  };\n  const getDelay = () => {\n    if (forceDelayValue !== undefined) {\n      return forceDelayValue;\n    }\n    if (_delay !== undefined) {\n      return _delay;\n    }\n    if (parentAnimation) {\n      return parentAnimation.getDelay();\n    }\n    return 0;\n  };\n  const getKeyframes = () => {\n    return _keyframes;\n  };\n  const direction = (animationDirection) => {\n    _direction = animationDirection;\n    update(true);\n    return ani;\n  };\n  const fill = (animationFill) => {\n    _fill = animationFill;\n    update(true);\n    return ani;\n  };\n  const delay = (animationDelay) => {\n    _delay = animationDelay;\n    update(true);\n    return ani;\n  };\n  const easing = (animationEasing) => {\n    _easing = animationEasing;\n    update(true);\n    return ani;\n  };\n  const duration = (animationDuration) => {\n    /**\n     * CSS Animation Durations of 0ms work fine on Chrome\n     * but do not run on Safari, so force it to 1ms to\n     * get it to run on both platforms.\n     */\n    if (!supportsWebAnimations && animationDuration === 0) {\n      animationDuration = 1;\n    }\n    _duration = animationDuration;\n    update(true);\n    return ani;\n  };\n  const iterations = (animationIterations) => {\n    _iterations = animationIterations;\n    update(true);\n    return ani;\n  };\n  const parent = (animation) => {\n    parentAnimation = animation;\n    return ani;\n  };\n  const addElement = (el) => {\n    if (el != null) {\n      if (el.nodeType === 1) {\n        elements.push(el);\n      }\n      else if (el.length >= 0) {\n        for (let i = 0; i < el.length; i++) {\n          elements.push(el[i]);\n        }\n      }\n      else {\n        console.error('Invalid addElement value');\n      }\n    }\n    return ani;\n  };\n  const addAnimation = (animationToAdd) => {\n    if (animationToAdd != null) {\n      if (Array.isArray(animationToAdd)) {\n        for (const animation of animationToAdd) {\n          animation.parent(ani);\n          childAnimations.push(animation);\n        }\n      }\n      else {\n        animationToAdd.parent(ani);\n        childAnimations.push(animationToAdd);\n      }\n    }\n    return ani;\n  };\n  const keyframes = (keyframeValues) => {\n    const different = _keyframes !== keyframeValues;\n    _keyframes = keyframeValues;\n    if (different) {\n      updateKeyframes(_keyframes);\n    }\n    return ani;\n  };\n  const updateKeyframes = (keyframeValues) => {\n    if (supportsWebAnimations) {\n      getWebAnimations().forEach((animation) => {\n        /**\n         * animation.effect's type is AnimationEffect.\n         * However, in this case we have a more specific\n         * type of AnimationEffect called KeyframeEffect which\n         * inherits from AnimationEffect. As a result,\n         * we cast animation.effect to KeyframeEffect.\n         */\n        const keyframeEffect = animation.effect;\n        /**\n         * setKeyframes is not supported in all browser\n         * versions that Ionic supports, so we need to\n         * check for support before using it.\n         */\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (keyframeEffect.setKeyframes) {\n          keyframeEffect.setKeyframes(keyframeValues);\n        }\n        else {\n          const newEffect = new KeyframeEffect(keyframeEffect.target, keyframeValues, keyframeEffect.getTiming());\n          animation.effect = newEffect;\n        }\n      });\n    }\n    else {\n      initializeCSSAnimation();\n    }\n  };\n  /**\n   * Run all \"before\" animation hooks.\n   */\n  const beforeAnimation = () => {\n    // Runs all before read callbacks\n    _beforeAddReadFunctions.forEach((callback) => callback());\n    // Runs all before write callbacks\n    _beforeAddWriteFunctions.forEach((callback) => callback());\n    // Updates styles and classes before animation runs\n    const addClasses = beforeAddClasses;\n    const removeClasses = beforeRemoveClasses;\n    const styles = beforeStylesValue;\n    elements.forEach((el) => {\n      const elementClassList = el.classList;\n      addClasses.forEach((c) => elementClassList.add(c));\n      removeClasses.forEach((c) => elementClassList.remove(c));\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n  };\n  /**\n   * Run all \"after\" animation hooks.\n   */\n  const afterAnimation = () => {\n    clearCSSAnimationsTimeout();\n    // Runs all after read callbacks\n    _afterAddReadFunctions.forEach((callback) => callback());\n    // Runs all after write callbacks\n    _afterAddWriteFunctions.forEach((callback) => callback());\n    // Updates styles and classes before animation ends\n    const currentStep = willComplete ? 1 : 0;\n    const addClasses = afterAddClasses;\n    const removeClasses = afterRemoveClasses;\n    const styles = afterStylesValue;\n    elements.forEach((el) => {\n      const elementClassList = el.classList;\n      addClasses.forEach((c) => elementClassList.add(c));\n      removeClasses.forEach((c) => elementClassList.remove(c));\n      for (const property in styles) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles.hasOwnProperty(property)) {\n          setStyleProperty(el, property, styles[property]);\n        }\n      }\n    });\n    onFinishCallbacks.forEach((onFinishCallback) => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.forEach((onFinishCallback) => {\n      return onFinishCallback.c(currentStep, ani);\n    });\n    onFinishOneTimeCallbacks.length = 0;\n    shouldCalculateNumAnimations = true;\n    if (willComplete) {\n      finished = true;\n    }\n    willComplete = true;\n  };\n  const animationFinish = () => {\n    if (numAnimationsRunning === 0) {\n      return;\n    }\n    numAnimationsRunning--;\n    if (numAnimationsRunning === 0) {\n      afterAnimation();\n      if (parentAnimation) {\n        parentAnimation.animationFinish();\n      }\n    }\n  };\n  const initializeCSSAnimation = (toggleAnimationName = true) => {\n    cleanUpStyleSheets();\n    const processedKeyframes = processKeyframes(_keyframes);\n    elements.forEach((element) => {\n      if (processedKeyframes.length > 0) {\n        const keyframeRules = generateKeyframeRules(processedKeyframes);\n        keyframeName = animationId !== undefined ? animationId : generateKeyframeName(keyframeRules);\n        const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);\n        stylesheets.push(stylesheet);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill());\n        setStyleProperty(element, 'animation-direction', getDirection());\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        setStyleProperty(element, 'animation-play-state', 'paused');\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);\n        }\n        raf(() => {\n          setStyleProperty(element, 'animation-name', stylesheet.id || null);\n        });\n      }\n    });\n  };\n  const initializeWebAnimation = () => {\n    elements.forEach((element) => {\n      const animation = element.animate(_keyframes, {\n        id,\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection(),\n      });\n      animation.pause();\n      webAnimations.push(animation);\n    });\n    if (webAnimations.length > 0) {\n      webAnimations[0].onfinish = () => {\n        animationFinish();\n      };\n    }\n  };\n  const initializeAnimation = (toggleAnimationName = true) => {\n    beforeAnimation();\n    if (_keyframes.length > 0) {\n      if (supportsWebAnimations) {\n        initializeWebAnimation();\n      }\n      else {\n        initializeCSSAnimation(toggleAnimationName);\n      }\n    }\n    initialized = true;\n  };\n  const setAnimationStep = (step) => {\n    step = Math.min(Math.max(step, 0), 0.9999);\n    if (supportsWebAnimations) {\n      webAnimations.forEach((animation) => {\n        // When creating the animation the delay is guaranteed to be set to a number.\n        animation.currentTime = animation.effect.getComputedTiming().delay + getDuration() * step;\n        animation.pause();\n      });\n    }\n    else {\n      const animationDuration = `-${getDuration() * step}ms`;\n      elements.forEach((element) => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-delay', animationDuration);\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        }\n      });\n    }\n  };\n  const updateWebAnimation = (step) => {\n    webAnimations.forEach((animation) => {\n      animation.effect.updateTiming({\n        delay: getDelay(),\n        duration: getDuration(),\n        easing: getEasing(),\n        iterations: getIterations(),\n        fill: getFill(),\n        direction: getDirection(),\n      });\n    });\n    if (step !== undefined) {\n      setAnimationStep(step);\n    }\n  };\n  const updateCSSAnimation = (toggleAnimationName = true, step) => {\n    raf(() => {\n      elements.forEach((element) => {\n        setStyleProperty(element, 'animation-name', keyframeName || null);\n        setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);\n        setStyleProperty(element, 'animation-timing-function', getEasing());\n        setStyleProperty(element, 'animation-delay', step !== undefined ? `-${step * getDuration()}ms` : `${getDelay()}ms`);\n        setStyleProperty(element, 'animation-fill-mode', getFill() || null);\n        setStyleProperty(element, 'animation-direction', getDirection() || null);\n        const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();\n        setStyleProperty(element, 'animation-iteration-count', iterationsCount);\n        if (toggleAnimationName) {\n          setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);\n        }\n        raf(() => {\n          setStyleProperty(element, 'animation-name', keyframeName || null);\n        });\n      });\n    });\n  };\n  const update = (deep = false, toggleAnimationName = true, step) => {\n    if (deep) {\n      childAnimations.forEach((animation) => {\n        animation.update(deep, toggleAnimationName, step);\n      });\n    }\n    if (supportsWebAnimations) {\n      updateWebAnimation(step);\n    }\n    else {\n      updateCSSAnimation(toggleAnimationName, step);\n    }\n    return ani;\n  };\n  const progressStart = (forceLinearEasing = false, step) => {\n    childAnimations.forEach((animation) => {\n      animation.progressStart(forceLinearEasing, step);\n    });\n    pauseAnimation();\n    shouldForceLinearEasing = forceLinearEasing;\n    if (!initialized) {\n      initializeAnimation();\n    }\n    update(false, true, step);\n    return ani;\n  };\n  const progressStep = (step) => {\n    childAnimations.forEach((animation) => {\n      animation.progressStep(step);\n    });\n    setAnimationStep(step);\n    return ani;\n  };\n  const progressEnd = (playTo, step, dur) => {\n    shouldForceLinearEasing = false;\n    childAnimations.forEach((animation) => {\n      animation.progressEnd(playTo, step, dur);\n    });\n    if (dur !== undefined) {\n      forceDurationValue = dur;\n    }\n    finished = false;\n    willComplete = true;\n    if (playTo === 0) {\n      forceDirectionValue = getDirection() === 'reverse' ? 'normal' : 'reverse';\n      if (forceDirectionValue === 'reverse') {\n        willComplete = false;\n      }\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(1 - step);\n      }\n      else {\n        forceDelayValue = (1 - step) * getDuration() * -1;\n        update(false, false);\n      }\n    }\n    else if (playTo === 1) {\n      if (supportsWebAnimations) {\n        update();\n        setAnimationStep(step);\n      }\n      else {\n        forceDelayValue = step * getDuration() * -1;\n        update(false, false);\n      }\n    }\n    if (playTo !== undefined) {\n      onFinish(() => {\n        forceDurationValue = undefined;\n        forceDirectionValue = undefined;\n        forceDelayValue = undefined;\n      }, {\n        oneTimeCallback: true,\n      });\n      if (!parentAnimation) {\n        play();\n      }\n    }\n    return ani;\n  };\n  const pauseAnimation = () => {\n    if (initialized) {\n      if (supportsWebAnimations) {\n        webAnimations.forEach((animation) => {\n          animation.pause();\n        });\n      }\n      else {\n        elements.forEach((element) => {\n          setStyleProperty(element, 'animation-play-state', 'paused');\n        });\n      }\n      paused = true;\n    }\n  };\n  const pause = () => {\n    childAnimations.forEach((animation) => {\n      animation.pause();\n    });\n    pauseAnimation();\n    return ani;\n  };\n  const onAnimationEndFallback = () => {\n    cssAnimationsTimerFallback = undefined;\n    animationFinish();\n  };\n  const clearCSSAnimationsTimeout = () => {\n    if (cssAnimationsTimerFallback) {\n      clearTimeout(cssAnimationsTimerFallback);\n    }\n  };\n  const playCSSAnimations = () => {\n    clearCSSAnimationsTimeout();\n    raf(() => {\n      elements.forEach((element) => {\n        if (_keyframes.length > 0) {\n          setStyleProperty(element, 'animation-play-state', 'running');\n        }\n      });\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n    else {\n      /**\n       * This is a catchall in the event that a CSS Animation did not finish.\n       * The Web Animations API has mechanisms in place for preventing this.\n       * CSS Animations will not fire an `animationend` event\n       * for elements with `display: none`. The Web Animations API\n       * accounts for this, but using raw CSS Animations requires\n       * this workaround.\n       */\n      const animationDelay = getDelay() || 0;\n      const animationDuration = getDuration() || 0;\n      const animationIterations = getIterations() || 1;\n      // No need to set a timeout when animation has infinite iterations\n      if (isFinite(animationIterations)) {\n        cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);\n      }\n      animationEnd(elements[0], () => {\n        clearCSSAnimationsTimeout();\n        /**\n         * Ensure that clean up\n         * is always done a frame\n         * before the onFinish handlers\n         * are fired. Otherwise, there\n         * may be flickering if a new\n         * animation is started on the same\n         * element too quickly\n         */\n        raf(() => {\n          clearCSSAnimationPlayState();\n          raf(animationFinish);\n        });\n      });\n    }\n  };\n  const clearCSSAnimationPlayState = () => {\n    elements.forEach((element) => {\n      removeStyleProperty(element, 'animation-duration');\n      removeStyleProperty(element, 'animation-delay');\n      removeStyleProperty(element, 'animation-play-state');\n    });\n  };\n  const playWebAnimations = () => {\n    webAnimations.forEach((animation) => {\n      animation.play();\n    });\n    if (_keyframes.length === 0 || elements.length === 0) {\n      animationFinish();\n    }\n  };\n  const resetAnimation = () => {\n    if (supportsWebAnimations) {\n      setAnimationStep(0);\n      updateWebAnimation();\n    }\n    else {\n      updateCSSAnimation();\n    }\n  };\n  const play = (opts) => {\n    return new Promise((resolve) => {\n      if (opts === null || opts === void 0 ? void 0 : opts.sync) {\n        shouldForceSyncPlayback = true;\n        onFinish(() => (shouldForceSyncPlayback = false), { oneTimeCallback: true });\n      }\n      if (!initialized) {\n        initializeAnimation();\n      }\n      if (finished) {\n        resetAnimation();\n        finished = false;\n      }\n      if (shouldCalculateNumAnimations) {\n        numAnimationsRunning = childAnimations.length + 1;\n        shouldCalculateNumAnimations = false;\n      }\n      /**\n       * When one of these callbacks fires we\n       * need to clear the other's callback otherwise\n       * you can potentially get these callbacks\n       * firing multiple times if the play method\n       * is subsequently called.\n       * Example:\n       * animation.play() (onStop and onFinish callbacks are registered)\n       * animation.stop() (onStop callback is fired, onFinish is not)\n       * animation.play() (onStop and onFinish callbacks are registered)\n       * Total onStop callbacks: 1\n       * Total onFinish callbacks: 2\n       */\n      const onStopCallback = () => {\n        clearCallback(onFinishCallback, onFinishOneTimeCallbacks);\n        resolve();\n      };\n      const onFinishCallback = () => {\n        clearCallback(onStopCallback, onStopOneTimeCallbacks);\n        resolve();\n      };\n      /**\n       * The play method resolves when an animation\n       * run either finishes or is cancelled.\n       */\n      onFinish(onFinishCallback, { oneTimeCallback: true });\n      onStop(onStopCallback, { oneTimeCallback: true });\n      childAnimations.forEach((animation) => {\n        animation.play();\n      });\n      if (supportsWebAnimations) {\n        playWebAnimations();\n      }\n      else {\n        playCSSAnimations();\n      }\n      paused = false;\n    });\n  };\n  /**\n   * Stops an animation and resets it state to the\n   * beginning. This does not fire any onFinish\n   * callbacks because the animation did not finish.\n   * However, since the animation was not destroyed\n   * (i.e. the animation could run again) we do not\n   * clear the onFinish callbacks.\n   */\n  const stop = () => {\n    childAnimations.forEach((animation) => {\n      animation.stop();\n    });\n    if (initialized) {\n      cleanUpElements();\n      initialized = false;\n    }\n    resetFlags();\n    onStopOneTimeCallbacks.forEach((onStopCallback) => onStopCallback.c(0, ani));\n    onStopOneTimeCallbacks.length = 0;\n  };\n  const from = (property, value) => {\n    const firstFrame = _keyframes[0];\n    if (firstFrame !== undefined && (firstFrame.offset === undefined || firstFrame.offset === 0)) {\n      firstFrame[property] = value;\n    }\n    else {\n      _keyframes = [{ offset: 0, [property]: value }, ..._keyframes];\n    }\n    return ani;\n  };\n  const to = (property, value) => {\n    const lastFrame = _keyframes[_keyframes.length - 1];\n    if (lastFrame !== undefined && (lastFrame.offset === undefined || lastFrame.offset === 1)) {\n      lastFrame[property] = value;\n    }\n    else {\n      _keyframes = [..._keyframes, { offset: 1, [property]: value }];\n    }\n    return ani;\n  };\n  const fromTo = (property, fromValue, toValue) => {\n    return from(property, fromValue).to(property, toValue);\n  };\n  return (ani = {\n    parentAnimation,\n    elements,\n    childAnimations,\n    id,\n    animationFinish,\n    from,\n    to,\n    fromTo,\n    parent,\n    play,\n    pause,\n    stop,\n    destroy,\n    keyframes,\n    addAnimation,\n    addElement,\n    update,\n    fill,\n    direction,\n    iterations,\n    duration,\n    easing,\n    delay,\n    getWebAnimations,\n    getKeyframes,\n    getFill,\n    getDirection,\n    getDelay,\n    getIterations,\n    getEasing,\n    getDuration,\n    afterAddRead,\n    afterAddWrite,\n    afterClearStyles,\n    afterStyles,\n    afterRemoveClass,\n    afterAddClass,\n    beforeAddRead,\n    beforeAddWrite,\n    beforeClearStyles,\n    beforeStyles,\n    beforeRemoveClass,\n    beforeAddClass,\n    onFinish,\n    isRunning,\n    progressStart,\n    progressStep,\n    progressEnd,\n  });\n};\n\nexport { createAnimation as c };\n"],"x_google_ignoreList":[0]}